function escapeMarkdownV2(text) {
	if (!text) return '';
	return text.replace(/([\_*\[\]\(\)~`>#+\-=|\{}\.!])/g, '\\$1');
}


function createReplyKeyboard() {
	return {
		keyboard: [
			[
				{ 
					text: "ğŸ‘¤ æŸ¥è¯¢ç”¨æˆ· ID",
					request_user: {
						request_id: 1, 
						user_is_bot: false, 
					}
				},
				{
					text: "ğŸ¤– æŸ¥è¯¢æœºå™¨äºº ID",
					request_user: {
						request_id: 2,
						user_is_bot: true, 
					}
				}
			],
			[
				{
					text: "ğŸ‘¥ æŸ¥è¯¢ç¾¤ç»„/é¢‘é“ ID",
					request_chat: {
						request_id: 3,
						chat_is_channel: false, 
					}
				},
				{
					text: "ğŸ“¢ æŸ¥è¯¢é¢‘é“ ID",
					request_chat: {
						request_id: 4,
						chat_is_channel: true, 
					}
				}
			]
		],
		resize_keyboard: true, 	
		one_time_keyboard: false 
	};
}

async function sendResponse(chatId, text, env, reply_markup = null) {
	const telegramApiUrl = `https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`;
	
	const body = {
		chat_id: chatId,
		text: text,
		parse_mode: 'MarkdownV2',
	};

	if (reply_markup) {
		body.reply_markup = reply_markup;
	}

	const response = await fetch(telegramApiUrl, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(body),
	});

	if (!response.ok) {
		console.error('Telegram API error:', response.status, await response.text());
	}

	return new Response('Message sent', { status: 200 });
}


async function handleStartCommand(message, env) {
	const chatId = message.chat.id;
	const userId = message.from.id;

	const now = new Date();
	const beijingTime = now.toLocaleString('zh-CN', {
		timeZone: 'Asia/Shanghai',
		hour12: false,
		year: 'numeric',
		month: '2-digit',
		day: '2-digit',
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit'
	});

	let rawAdText = '';
	if (env.AD_TEXT && env.AD_TEXT.toLowerCase() !== 'none') {
		rawAdText = escapeMarkdownV2(env.AD_TEXT); 
	}

	let responseText = `ğŸ‘‹ æ¬¢è¿ä½¿ç”¨ Telegram ID æŸ¥è¯¢åŠ©æ‰‹ 
ğŸ•° å½“å‰æ—¶é—´ï¼š ${escapeMarkdownV2(beijingTime)}
ğŸ“Œ æ‚¨çš„ç”¨æˆ·IDï¼š\`${userId}\``;
	
	if (rawAdText) {
		responseText += `\n\n${rawAdText}`; 
	}


	return sendResponse(chatId, responseText, env, createReplyKeyboard());
}


async function handleRequest(request, env) {
	if (request.method !== 'POST') {
		return new Response('OK', { status: 200 });
	}

	try {
		const payload = await request.json();

		const chatId = payload.message ? payload.message.chat.id : null;

		if (payload.message && payload.message.user_shared && chatId) {
			const sharedUserId = payload.message.user_shared.user_id;
			const messageText = `âœ… **ID æŸ¥è¯¢æˆåŠŸï¼**\n\næ‚¨åˆ†äº«çš„å¯¹è±¡çš„ ID æ˜¯ï¼š\`${sharedUserId}\``;
			return sendResponse(chatId, messageText, env, createReplyKeyboard());
		}

		if (payload.message && payload.message.chat_shared && chatId) {
			const sharedChatId = payload.message.chat_shared.chat_id; 
			const messageText = `âœ… **ID æŸ¥è¯¢æˆåŠŸï¼**\n\næ‚¨åˆ†äº«çš„ç¾¤ç»„/é¢‘é“çš„ ID æ˜¯ï¼š\`${sharedChatId}\``;
			return sendResponse(chatId, messageText, env, createReplyKeyboard());
		}
		
		if (payload.message && payload.message.text && payload.message.text.startsWith('/start')) {
			return handleStartCommand(payload.message, env);
		}

		return new Response('OK', { status: 200 });

	} catch (e) {
		console.error('Error processing request:', e.message);
		return new Response('Bad Request', { status: 400 });
	}
}

export default {
	fetch: handleRequest,
};
